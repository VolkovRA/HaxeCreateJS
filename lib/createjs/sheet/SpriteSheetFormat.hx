package createjs.sheet;

import haxe.extern.EitherType;
import js.html.ImageElement;

/**
 * SpriteSheets are an object with two required properties (images and frames), and two optional properties (framerate and animations).
 * This makes them easy to define in javascript code, or in JSON.
 * 
 * The data passed to the SpriteSheet constructor defines:
 *   1. The source image or images to use.
 *   2. The positions of individual image frames.
 *   3. Sequences of frames that form named animations. Optional.
 *   4. The target playback framerate. Optional.
 * 
 * <b>Example</b>
 * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three animations: "stand"
 * showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing frame 6-8 and sequencing back to run.
 * <code>
 * var data = {
 *     images: ["sprites.jpg"],
 *     frames: {width:50, height:50},
 *     animations: {
 *         stand:0,
 *         run:[1,5],
 *         jump:[6,8,"run"]
 *     }
 * };
 * var spriteSheet = new SpriteSheet(data);
 * var animation = new Sprite(spriteSheet, "run");
 * </code>
 * 
 * Documentation: https://www.createjs.com/docs/easeljs/classes/SpriteSheet.html
 * @author VolkovRA
 */
typedef SpriteSheetFormat =
{
	/**
	 * An array of source images.
	 * Images can be either an HTMlimage instance, or a uri to an image.
	 * The former is recommended to control preloading.
	 * <code>images: [image1, "path/to/image2.png"],</code>
	 */
	var images:Array<EitherType<ImageElement, String>>;
	
	/**
	 * Defines the individual frames.
	 * There are two supported formats for frame data:
	 *   1. All of the frames are the same size (in a grid).
	 *   2. The frames are of different sizes.
	 */
	var frames:EitherType<SameFrames, DifferentFrames>;
	
	/**
	 * An object defining sequences of frames to play as named animations.
	 * Each property corresponds to an animation of the same name.
	 * Each animation must specify the frames to play, and may also include a relative playback speed (ex. 2 would playback at
	 * double speed, 0.5 at half), and the name of the next animation to sequence to after it completes.
	 * 
	 * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate.
	 */
	@:optional var animations:Map<AnimationName, AnimationData>;
	
	/**
	 * Indicates the default framerate to play this spritesheet at in frames per second.
	 * See framerate for more information.
	 * <code>framerate: 20</code>
	 * Note that the Sprite framerate will only work if the stage update method is provided with the tick event generated by the Ticker.
	 * </code>
	 * Ticker.on("tick", handleTick);
	 * function handleTick(event) {
	 *     stage.update(event);
	 * }
	 * </code>
	 */
	@:optional var framerate:Float;
}

/**
 * All of the frames are the same size (in a grid).
 * <code>
 * frames: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}
 * </code>
 */
typedef SameFrames =
{
	/**
	 * Are required and specify the dimensions of the frames.
	 */
	var width:Int;
	
	/**
	 * Are required and specify the dimensions of the frames.
	 */
	var height:Int;
	
	/**
	 * Indicate the registration point or "origin" of the frames.
	 */
	@:optional var regX:Float;
	
	/**
	 * Indicate the registration point or "origin" of the frames.
	 */
	@:optional var regY:Float;
	
	/**
	 * Indicate the spacing between frames.
	 */
	@:optional var spacing:Int;
	
	/**
	 * Specify the margin around the image(s).
	 */
	@:optional var margin:Int;
	
	/**
	 * Allows you to specify the total number of frames in the spritesheet.
	 * If omitted, this will be calculated based on the dimensions of the source images and the frames.
	 * Frames will be assigned indexes based on their position in the source images (left to right, top to bottom).
	 */
	@:optional var count:Int;
}

/**
 * The frames are of different sizes.
 * Each definition is itself an array with 4 required and 3 optional entries, in the order:
 *   1. The first four, x, y, width, and height are required and define the frame rectangle.
 *   2. The fifth, imageIndex, specifies the index of the source image (defaults to 0).
 *   3. The last two, regX and regY specify the registration point of the frame.
 * <code>
 * frames: [
 *     // x, y, width, height, imageIndex*, regX*, regY*
 *     [64, 0, 96, 64],
 *     [0, 0, 64, 64, 1, 32, 32]
 *     // etc.
 * ]
 * </code>
 */
typedef DifferentFrames = Array<Array<Float>>;

/**
 * The animation data can be:
 *   1. A single frame animation with specify the frame index.
 *   2. Animation of consecutive frames, using an array with two required, and two optional entries in the order: start, end, next, and speed. This will play the frames from start to end inclusive.
 *   3. Non-consecutive frames, using an object with a frames property defining an array of frame indexes to play in order. The object can also specify next and speed properties.
 * 
 * Example:
 * <code>
 * // Single frame:
 * animations: {
 *     sit: 7
 * }
 * 
 * // Animation of consecutive frames:
 * animations: {
 * // start, end, next*, speed*
 *     run: [0, 8],
 *     jump: [9, 12, "run", 2]
 * }
 * 
 * // Non-consecutive frames:
 * animations: {
 *     walk: {
 *         frames: [1,2,3,3,2,1]
 *     },
 *     shoot: {
 *         frames: [1,4,5,6],
 *         next: "walk",
 *         speed: 0.5
 *     }
 * }
 * </code>
 */
typedef AnimationData = EitherType<FrameIndex, EitherType<AnimationDataConsecutive, AnimationDataNonConsecutive>>;

/**
 * Animation of consecutive frames, using an array with two required, and two optional entries in the order: start, end, next, and speed.
 * This will play the frames from start to end inclusive.
 * <code>
 * animations: {
 * // start, end, next*, speed*
 *     run: [0, 8],
 *     jump: [9, 12, "run", 2]
 * }
 * </code>
 */
typedef AnimationDataConsecutive = Array<EitherType<FrameIndex, AnimationName>>;

/**
 * Non-consecutive frames, using an object with a frames property defining an array of frame indexes to play in order.
 * The object can also specify next and speed properties.
 * <code>
 * animations: {
 *     walk: {
 *         frames: [1,2,3,3,2,1]
 *     },
 *     shoot: {
 *         frames: [1,4,5,6],
 *         next: "walk",
 *         speed: 0.5
 *     }
 * }
 * </code>
 * 
 * Note: the speed property was added in EaselJS 0.7.0. Earlier versions had a frequency property instead, which was the inverse of speed.
 * For example, a value of "4" would be 1/4 normal speed in earlier versions, but is 4x normal speed in EaselJS 0.7.0+.
 */
typedef AnimationDataNonConsecutive = 
{
	/**
	 * Defining an array of frame indexes to play in order.
	 */
	var frames:Array<EitherType<FrameIndex, AnimationName>>;
	
	/**
	 * Name of the next animation to sequence to after it completes.
	 */
	@:optional var next:EitherType<FrameIndex, AnimationName>;
	
	/**
	 * Relative playback speed.
	 * Example: 2 would playback at double speed, 0.5 at half.
	 * Added in EaselJS 0.7.0
	 */
	@:optional var speed:Float;
	
	/**
	 * Earlier versions had a current property to controll speed, which was the inverse of speed.
	 * For example, a value of "4" would be 1/4 normal speed in earlier versions, but is 4x normal speed in EaselJS 0.7.0+.
	 */
	@:optional var frequency:Float;
}